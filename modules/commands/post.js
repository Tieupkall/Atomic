module.exports.run = async ({ event, api, args }) => {
	const { threadID, messageID, senderID } = event;
	const permission = global.config.NDH;

	if (!permission.includes(senderID))
		return api.sendMessage("B·∫°n kh√¥ng ƒë∆∞·ª£c ph√©p d√πng l·ªánh n√†y", threadID, messageID);

	// Kh·ªüi t·∫°o scheduler n·∫øu ch∆∞a c√≥
	const currentScheduler = initScheduler(api);

	// X·ª≠ l√Ω l·ªánh auto-post
	if (args[0] === '-auto') {
		return handleAutoPostCommand(api, event, args);
	}

	// Ki·ªÉm tra c√°c lo·∫°i post th√¥ng th∆∞·ªùng
	let isGroupPost = false;
	let isAllGroupPost = false;
	let targetGroupID = null;
	let content = args.join(" ");

	if (args[0] === '-g' && args[1]) {
		isGroupPost = true;
		targetGroupID = args[1];
		content = args.slice(2).join(" ");
	} else if (args[0] === '-all') {
		isAllGroupPost = true;
		content = args.slice(1).join(" ");
	}

	if (args.length === 0) {
		return api.sendMessage(
			`ü§ñ L·ªÜNH POST - H∆Ø·ªöNG D·∫™N S·ª¨ D·ª§NG:\n\n` +
			`üìù ƒêƒÇNG B√ÄI TH√îNG TH∆Ø·ªúNG:\n` +
			`‚Ä¢ /post [n·ªôi dung] - ƒëƒÉng l√™n trang c√° nh√¢n bot\n` +
			`‚Ä¢ /post -g [groupID] [n·ªôi dung] - ƒëƒÉng l√™n nh√≥m\n` +
			`‚Ä¢ /post -all - ƒëƒÉng l√™n t·∫•t c·∫£ nh√≥m\n\n` +
			`ü§ñ T·ª∞ ƒê·ªòNG ƒêƒÇNG B√ÄI:\n` +
			`‚Ä¢ /post -auto help - xem h∆∞·ªõng d·∫´n auto-post\n` +
			`‚Ä¢ /post -auto status - xem tr·∫°ng th√°i\n` +
			`‚Ä¢ /post -auto list - danh s√°ch b√†i vi·∫øt t·ª± ƒë·ªông\n\n` +
			`‚Ä¢ /post -auto add [n·ªôi dung] - thay th·∫ø n·ªôi dung ƒëƒÉng l√™n c√°c nh√≥m\n\n` +
			`Ph·∫£n h·ªìi tin nh·∫Øn n√†y v·ªõi n·ªôi dung mu·ªën t·∫°o b√†i vi·∫øt:`, 
			threadID, (e, info) => {
				global.client.handleReply.push({
					name: this.config.name,
					messageID: info.messageID,
					author: senderID,
					type: "createPost"
				});
			}, messageID);
	} else {
		const botID = api.getCurrentUserID();



		try {
			if (isAllGroupPost) {
				// ƒêƒÉng l√™n t·∫•t c·∫£ nh√≥m
				const groupsList = getGroupsList();
				if (groupsList.length === 0) {
					return api.sendMessage("Kh√¥ng c√≥ nh√≥m n√†o trong danh s√°ch. Vui l√≤ng ki·ªÉm tra file groups.json", threadID, messageID);
				}

				let results = [];
				let successCount = 0;
				let failCount = 0;

				api.sendMessage(`üîÑ B·∫Øt ƒë·∫ßu ƒëƒÉng b√†i l√™n ${groupsList.length} nh√≥m...`, threadID, messageID);

				for (const group of groupsList) {
					try {
						await new Promise(resolve => setTimeout(resolve, 2000)); // Delay 2s gi·ªØa c√°c post
						const result = await createSinglePost(api, botID, content, group.id);
						results.push(`‚úÖ ${group.name}: Th√†nh c√¥ng`);
						successCount++;

						// G·ª≠i th√¥ng b√°o ri√™ng cho t·ª´ng nh√≥m th√†nh c√¥ng
						const successMsg = `üéâ ƒêƒÉng b√†i th√†nh c√¥ng!\nüìù Nh√≥m: ${group.name}\nüÜî Post ID: ${result.postID}\nüîó Link: ${result.urlPost}`;
						api.sendMessage(successMsg, threadID);

					} catch (error) {
						results.push(`‚ùå ${group.name}: ${error.message}`);
						failCount++;
					}
				}

				const summary = `üìä K·∫æT QU·∫¢ ƒêƒÇNG TO√ÄN B·ªò NH√ìM:\n‚Ä¢ Th√†nh c√¥ng: ${successCount}/${groupsList.length}\n‚Ä¢ Th·∫•t b·∫°i: ${failCount}/${groupsList.length}\n\n${results.join('\n')}`;
				return api.sendMessage(summary, threadID, messageID);

			} else if (isGroupPost) {
				// ƒêƒÉng l√™n nh√≥m c·ª• th·ªÉ
				try {
					const result = await createSinglePost(api, botID, content, targetGroupID);
					return api.sendMessage(`¬ª ƒê√£ t·∫°o b√†i vi·∫øt th√†nh c√¥ng l√™n nh√≥m\n¬ª postID: ${result.postID}\n¬ª urlPost: ${result.urlPost}`, threadID, messageID);
				} catch (error) {
					return api.sendMessage(`T·∫°o b√†i vi·∫øt th·∫•t b·∫°i: ${error.message}`, threadID, messageID);
				}
			} else {
				// ƒêƒÉng l√™n timeline
				try {
					const result = await createSinglePost(api, botID, content);
					return api.sendMessage(`¬ª ƒê√£ t·∫°o b√†i vi·∫øt th√†nh c√¥ng l√™n timeline\n¬ª postID: ${result.postID}\n¬ª urlPost: ${result.urlPost}`, threadID, messageID);
				} catch (error) {
					return api.sendMessage(`T·∫°o b√†i vi·∫øt th·∫•t b·∫°i: ${error.message}`, threadID, messageID);
				}
			}

		} catch (error) {
			return api.sendMessage(`L·ªói x·ª≠ l√Ω: ${error.message}`, threadID, messageID);
		}
	}
};const fs = require('fs');
const path = require('path');
const AutoPostScheduler = require('../utils/autopost'); // Import scheduler
const schedule = require('node-schedule');
module.exports.config = {
	name: "post",
	version: "2.0.0",
	hasPermssion: 2,
	credits: "Atomic",
	description: "T·∫°o b√†i vi·∫øt Facebook v√† qu·∫£n l√Ω auto-post",
	usages: "post [n·ªôi dung] | post -g [groupID] [n·ªôi dung] | post -all [n·ªôi dung] | post -auto [options]",
	commandCategory: "Admin",
	cooldowns: 5
};

module.exports.languages = {
	"vi": {},
	"en": {}
};

// Kh·ªüi t·∫°o scheduler
let scheduler = null;

const appState = require("../../includes/login/bkup.json");
const cookie = appState.map(item => item = item.key + "=" + item.value).join(";");

// ƒê·ªçc file groups.json
const getGroupsList = () => {
	try {
		const groupsPath = path.join(__dirname, '..', '..', 'data', 'post', 'groups.json');
		if (fs.existsSync(groupsPath)) {
			const data = fs.readFileSync(groupsPath, 'utf8');
			const groupsData = JSON.parse(data);
			return groupsData.groups || [];
		}
		return [];
	} catch (error) {
		console.log("L·ªói ƒë·ªçc file groups.json:", error);
		return [];
	}
};

// ƒê·ªçc v√† l∆∞u auto post config
const getAutoPostConfig = () => {
	try {
		const configPath = path.join(__dirname, '..', '..', 'data', 'post', 'autopost_config.json');
		if (fs.existsSync(configPath)) {
			const data = fs.readFileSync(configPath, 'utf8');
			return JSON.parse(data);
		}
		return null;
	} catch (error) {
		console.log("L·ªói ƒë·ªçc file autopost_config.json:", error);
		return null;
	}
};

const saveAutoPostConfig = (config) => {
	try {
		const configPath = path.join(__dirname, '..', '..', 'data', 'post', 'autopost_config.json');
		fs.writeFileSync(configPath, JSON.stringify(config, null, 2), 'utf8');
		return true;
	} catch (error) {
		console.log("L·ªói l∆∞u file autopost_config.json:", error);
		return false;
	}
};

// Format th·ªùi gian Vi·ªát Nam
const formatVietnamTime = (timestamp) => {
	return new Date(timestamp).toLocaleString('vi-VN', { 
		timeZone: 'Asia/Ho_Chi_Minh',
		year: 'numeric',
		month: '2-digit', 
		day: '2-digit',
		hour: '2-digit',
		minute: '2-digit',
		second: '2-digit'
	});
};

// Kh·ªüi t·∫°o scheduler khi module load
const initScheduler = (api) => {
	if (!scheduler) {
		scheduler = new AutoPostScheduler(api);
		// ƒê·∫£m b·∫£o scheduler ƒë∆∞·ª£c l∆∞u v√†o global ƒë·ªÉ truy c·∫≠p t·ª´ c√°c l·ªánh kh√°c
		global.autoPostScheduler = scheduler;
		// B·∫Øt ƒë·∫ßu auto check config m·ªói 10 gi√¢y
		scheduler.startAutoConfigCheck();
	}
	return scheduler;
};

// T·∫°o GUID ƒë∆°n gi·∫£n
const getGUID = () => {
	return 'xxxx-xxxx-4xxx-yxxx-xxxx'.replace(/[xy]/g, function(c) {
		const r = Math.random() * 16 | 0;
		const v = c === 'x' ? r : (r & 0x3 | 0x8);
		return v.toString(16);
	}) + '_' + Date.now();
};

// T·∫°o b√†i vi·∫øt cho m·ªôt nh√≥m c·ª• th·ªÉ (ch·ªâ text)
const createSinglePost = async (api, botID, content, targetGroupID = null) => {
	const session_id = getGUID();
	const isGroupPost = !!targetGroupID;

	const form = {
		av: botID,
		fb_api_req_friendly_name: "ComposerStoryCreateMutation",
		fb_api_caller_class: "RelayModern",
		doc_id: "4612917415497545",
		variables: JSON.stringify({
			"input": {
				"composer_entry_point": "inline_composer",
				"composer_source_surface": isGroupPost ? "group" : "timeline",
				"composer_type": isGroupPost ? "group" : null,
				"idempotence_token": session_id + "_FEED",
				"source": "WWW",
				"attachments": [],
				"audience": isGroupPost ? {
					"to_id": targetGroupID
				} : {
					"privacy": {
						"allow": [],
						"base_state": "EVERYONE",
						"deny": [],
						"tag_expansion_state": "UNSPECIFIED"
					}
				},
				"message": {
					"ranges": [],
					"text": content || ""
				},
				"with_tags_ids": [],
				"inline_activities": [],
				"explicit_place_id": "0",
				"text_format_preset_id": "0",
				"logging": {
					"composer_session_id": session_id
				},
				"tracking": [null],
				"actor_id": botID,
				"client_mutation_id": Math.round(Math.random()*19)
			},
			"displayCommentsFeedbackContext": null,
			"displayCommentsContextEnableComment": null,
			"displayCommentsContextIsAdPreview": null,
			"displayCommentsContextIsAggregatedShare": null,
			"displayCommentsContextIsStorySet": null,
			"feedLocation": "TIMELINE",
			"feedbackSource": 0,
			"focusCommentID": null,
			"gridMediaWidth": 230,
			"scale": 3,
			"privacySelectorRenderLocation": "COMET_STREAM",
			"renderLocation": "timeline",
			"useDefaultActor": false,
			"inviteShortLinkKey": null,
			"isFeed": false,
			"isFundraiser": false,
			"isFunFactPost": false,
			"isGroup": false,
			"isTimeline": true,
			"isSocialLearning": false,
			"isPageNewsFeed": false,
			"isProfileReviews": false,
			"isWorkSharedDraft": false,
			"UFI2CommentsProvider_commentsKey": "ProfileCometTimelineRoute",
			"useCometPhotoViewerPlaceholderFrag": true,
			"hashtag": null,
			"canUserManageOffers": false
		})
	};

	return new Promise((resolve, reject) => {
		api.httpPost('https://www.facebook.com/api/graphql/', form, (e, i) => {
			try {
				if (e) return reject(e);

				const response = JSON.parse(i);

				if (response.data && response.data.story_create && response.data.story_create.story) {
					const postID = response.data.story_create.story.legacy_story_hideable_id;
					const urlPost = response.data.story_create.story.url;
					resolve({ postID, urlPost, success: true });
				} else if (response.errors && response.errors.length > 0) {
					reject(new Error(response.errors[0].message));
				} else {
					reject(new Error("T·∫°o b√†i vi·∫øt th·∫•t b·∫°i"));
				}
			} catch (parseError) {
				reject(parseError);
			}
		});
	});
};

// X·ª≠ l√Ω l·ªánh auto-post
const handleAutoPostCommand = async (api, event, args) => {
	const { threadID, messageID, senderID } = event;
	const permission = global.config.NDH;

	if (!permission.includes(senderID))
		return api.sendMessage("B·∫°n kh√¥ng ƒë∆∞·ª£c ph√©p d√πng l·ªánh n√†y", threadID, messageID);

	// ƒê·∫£m b·∫£o scheduler ƒë∆∞·ª£c kh·ªüi t·∫°o ƒë√∫ng c√°ch
	const autoScheduler = global.autoPostScheduler || initScheduler(api);
	const subCommand = args[1];

	const reply = (msg) => api.sendMessage(msg, threadID, messageID);
	const logsPath = path.join(__dirname, '..', '..', 'data', 'autopost_logs.json');

	// Logger function
	function logger(message, type = 'INFO', skipSave = false) {
		const now = new Date();
		const timeStr = formatVietnamTime(now);
		const logEntry = `üìù [${timeStr}] ${type}: ${message}`;

		console.log(logEntry);

		// Ch·ªâ l∆∞u v√†o file n·∫øu kh√¥ng c√≥ flag skipSave
		if (!skipSave) {
			// L∆∞u v√†o file logs
			const logData = {
				timestamp: now.toISOString(),
				time: timeStr,
				type: type,
				message: message
			};

			let logs = [];
			try {
				if (fs.existsSync(logsPath)) {
					logs = JSON.parse(fs.readFileSync(logsPath, 'utf8'));
				}
			} catch (error) {
				console.log('‚ùå L·ªói ƒë·ªçc file logs:', error.message);
			}

			logs.push(logData);

			// Gi·ªØ t·ªëi ƒëa 100 logs g·∫ßn nh·∫•t
			if (logs.length > 100) {
				logs = logs.slice(-100);
			}

			try {
				fs.writeFileSync(logsPath, JSON.stringify(logs, null, 2), 'utf8');
			} catch (error) {
				console.log('‚ùå L·ªói ghi file logs:', error.message);
			}
		}
	}

	// Kh·ªüi ƒë·ªông AutoPost Scheduler
	function startAutoPost(skipLogs = false) {
		try {
			if (timeCheckerInterval) {
				clearInterval(timeCheckerInterval);
			}

			// ƒê·ªçc config
			let config = [];
			try {
				if (fs.existsSync(configPath)) {
					config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
				}
			} catch (error) {
				logger(`L·ªói ƒë·ªçc config: ${error.message}`, 'ERROR', skipLogs);
				return;
			}

			if (config.length === 0) {
				logger('Kh√¥ng c√≥ b√†i vi·∫øt n√†o ƒë∆∞·ª£c c·∫•u h√¨nh', 'WARN', skipLogs);
				return;
			}

			// T·∫°o scheduler m·ªõi
			global.autoPostScheduler = schedule;

			// L√™n l·ªãch cho t·ª´ng b√†i vi·∫øt
			config.forEach((post, index) => {
				const { content, images, videos, schedule: postSchedule } = post;
				const { time, days } = postSchedule;

				// T·∫°o cron expression
				const [hour, minute] = time.split(':').map(Number);
				const dayNumbers = days.map(day => {
					const dayMap = { sunday: 0, monday: 1, tuesday: 2, wednesday: 3, thursday: 4, friday: 5, saturday: 6 };
					return dayMap[day.toLowerCase()];
				});

				const cronExpression = `${minute} ${hour} * * ${dayNumbers.join(',')}`;

				// T·∫°o job
				const jobName = `autopost_${index + 1}`;
				global.autoPostScheduler.scheduleJob(jobName, cronExpression, async () => {
					logger(`ƒêang th·ª±c hi·ªán auto post ID ${index + 1}`, 'INFO', skipLogs);
					await executeAutoPost(content, images, videos, index + 1, skipLogs);
				});

				logger(`ƒê√£ l√™n l·ªãch b√†i vi·∫øt ID ${index + 1}: ${time} v√†o ${days.join(', ')}`, 'INFO', skipLogs);
			});

			logger('AutoPost Scheduler ƒë√£ b·∫Øt ƒë·∫ßu ch·∫°y', 'INFO', skipLogs);

		} catch (error) {
			logger(`L·ªói kh·ªüi ƒë·ªông AutoPost: ${error.message}`, 'ERROR', skipLogs);
		}
	}

	// AutoPost ƒë√£ ƒë∆∞·ª£c chuy·ªÉn sang h·ªá th·ªëng m·ªõi trong autopost.js
	function stopAutoPost(skipLogs = false) {
		if (!skipLogs) {
			logger('AutoPost ƒë√£ ƒë∆∞·ª£c chuy·ªÉn sang h·ªá th·ªëng m·ªõi (autopost.js)', 'INFO', skipLogs);
		}
	}

	// Time Checker - ki·ªÉm tra v√† ch·∫°y scheduler m·ªói 10 gi√¢y
	let timeCheckerInterval;
	function startTimeChecker() {
		// Ki·ªÉm tra xem Time Checker ƒë√£ ch·∫°y ch∆∞a
		if (timeCheckerInterval) {
			clearInterval(timeCheckerInterval);
		}

		timeCheckerInterval = setInterval(() => {
			const now = new Date();

			// Ki·ªÉm tra xem scheduler c√≥ t·ªìn t·∫°i v√† ƒëang ho·∫°t ƒë·ªông kh√¥ng
			if (!global.autoPostScheduler || !global.autoPostScheduler.scheduledJobs || Object.keys(global.autoPostScheduler.scheduledJobs).length === 0) {
				// Ch·ªâ log m·ªôt l·∫ßn khi ph√°t hi·ªán v·∫•n ƒë·ªÅ
				if (!global.timeCheckerWarningLogged) {
					logger('Time Checker ph√°t hi·ªán scheduler ch∆∞a kh·ªüi t·∫°o ho·∫∑c kh√¥ng c√≥ jobs', 'WARN');
					global.timeCheckerWarningLogged = true;
				}
				return;
			}

			// Reset warning flag khi scheduler ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng
			global.timeCheckerWarningLogged = false;

		}, 10000); // 10 gi√¢y

		logger('Time Checker ƒë√£ b·∫Øt ƒë·∫ßu ch·∫°y (check m·ªói 10 gi√¢y)', 'INFO');
	}


	const configPath = path.join(__dirname, '..', '..', 'data', 'post', 'autopost_config.json');

	// Format time
	function formatTime(date) {
		const hours = String(date.getHours()).padStart(2, '0');
		const minutes = String(date.getMinutes()).padStart(2, '0');
		const seconds = String(date.getSeconds()).padStart(2, '0');
		return `${hours}:${minutes}:${seconds}`;
	}

	async function executeAutoPost(content, images, videos, postId, skipLogs = false) {
		try {
			const botID = api.getCurrentUserID();
			if (images && images.length > 0) {
				// X·ª≠ l√Ω ƒëƒÉng ·∫£nh
				const attachments = [];
				for (const image of images) {
					try {
						const imagePath = path.join(__dirname, '..', '..', 'data', 'post', image);
						if (fs.existsSync(imagePath)) {
							attachments.push(fs.createReadStream(imagePath));
						} else {
							logger(`·∫¢nh ${image} kh√¥ng t·ªìn t·∫°i.`, 'WARN', skipLogs);
						}
					} catch (error) {
						logger(`L·ªói ƒë·ªçc ·∫£nh ${image}: ${error.message}`, 'ERROR', skipLogs);
					}
				}

				if (attachments.length > 0) {
					const messageObject = {
						body: content,
						attachment: attachments
					};

					await api.sendMessage(messageObject, event.threadID);
					logger(`ƒê√£ ƒëƒÉng b√†i vi·∫øt ID ${postId} k√®m ·∫£nh.`, 'INFO', skipLogs);
				} else {
					logger(`Kh√¥ng c√≥ ·∫£nh n√†o h·ª£p l·ªá cho b√†i vi·∫øt ID ${postId}.`, 'WARN', skipLogs);
				}

			} else if (videos && videos.length > 0) {
				// X·ª≠ l√Ω video (t∆∞∆°ng t·ª± nh∆∞ ·∫£nh)
				const attachments = [];
				for (const video of videos) {
					try {
						const videoPath = path.join(__dirname, '..', '..', 'data', 'post', video);
						if (fs.existsSync(videoPath)) {
							attachments.push(fs.createReadStream(videoPath));
						} else {
							logger(`Video ${video} kh√¥ng t·ªìn t·∫°i.`, 'WARN', skipLogs);
						}
					} catch (error) {
						logger(`L·ªói ƒë·ªçc video ${video}: ${error.message}`, 'ERROR', skipLogs);
					}
				}

				if (attachments.length > 0) {
					const messageObject = {
						body: content,
						attachment: attachments
					};

					await api.sendMessage(messageObject, event.threadID);
					logger(`ƒê√£ ƒëƒÉng b√†i vi·∫øt ID ${postId} k√®m video.`, 'INFO', skipLogs);
				} else {
					logger(`Kh√¥ng c√≥ video n√†o h·ª£p l·ªá cho b√†i vi·∫øt ID ${postId}.`, 'WARN', skipLogs);
				}
			}
			else {
				// Ch·ªâ ƒëƒÉng text
				await api.sendMessage(content, event.threadID);
				logger(`ƒê√£ ƒëƒÉng b√†i vi·∫øt ID ${postId} (ch·ªâ text).`, 'INFO', skipLogs);
			}
		} catch (error) {
			logger(`L·ªói ƒëƒÉng b√†i vi·∫øt ID ${postId}: ${error.message}`, 'ERROR', skipLogs);
		}
	}

	switch (subCommand) {
		case 'start':
			try {
				// Ki·ªÉm tra option -nolog
                const noLog = args.includes('-nolog');
				if (global.autoPostScheduler && Object.keys(global.autoPostScheduler.scheduledJobs).length > 0) {
					return api.sendMessage("‚úÖ AutoPost Scheduler ƒë√£ ƒëang ch·∫°y!", event.threadID);
				}

				startAutoPost(noLog);
				startTimeChecker();
				api.sendMessage("‚úÖ AutoPost Scheduler ƒë√£ kh·ªüi ƒë·ªông th√†nh c√¥ng!", event.threadID);
			} catch (error) {
				logger(`L·ªói kh·ªüi ƒë·ªông AutoPost: ${error.message}`, 'ERROR');
				api.sendMessage(`‚ùå L·ªói kh·ªüi ƒë·ªông AutoPost: ${error.message}`, event.threadID);
			}
			break;

		case 'stop':
			try {
				// Ki·ªÉm tra n·∫øu c√≥ flag -auto
				if (args[2] === '-auto') {
					autoScheduler.stopAutoConfigCheck();
					autoScheduler.stopScheduler();
					return reply("‚úÖ ƒê√£ d·ª´ng AutoPost Scheduler v√† auto check!");
				} else {
					autoScheduler.stopScheduler();
					return reply("‚úÖ ƒê√£ d·ª´ng AutoPost Scheduler!");
				}
			} catch (error) {
				logger(`L·ªói d·ª´ng AutoPost: ${error.message}`, 'ERROR');
				api.sendMessage(`‚ùå L·ªói d·ª´ng AutoPost: ${error.message}`, event.threadID);
			}
			break;

		case 'restart':
			try {
				// ƒê·∫£m b·∫£o scheduler ƒë∆∞·ª£c kh·ªüi t·∫°o
				const currentScheduler = initScheduler(api);

				if (currentScheduler && typeof currentScheduler.restartSchedulerSilent === 'function') {
					currentScheduler.restartSchedulerSilent();
					reply('‚úÖ AutoPost Scheduler ƒë√£ ƒë∆∞·ª£c kh·ªüi ƒë·ªông l·∫°i th√†nh c√¥ng!');
				} else {
					// Kh·ªüi t·∫°o l·∫°i scheduler n·∫øu c·∫ßn
					scheduler = new AutoPostScheduler(api);
					global.autoPostScheduler = scheduler;
					scheduler.startAutoConfigCheck();
					reply('‚úÖ AutoPost Scheduler ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o v√† kh·ªüi ƒë·ªông th√†nh c√¥ng!');
				}
			} catch (error) {
				logger(`L·ªói kh·ªüi ƒë·ªông l·∫°i AutoPost: ${error.message}`, 'ERROR');
				api.sendMessage(`‚ùå L·ªói kh·ªüi ƒë·ªông l·∫°i AutoPost: ${error.message}`, event.threadID);
			}
			break;

		case 'status':
			const stats = autoScheduler.getStats();
			if (stats) {
				const statusMsg = `üìä TR·∫†NG TH√ÅI AUTO-POST:\n` +
					`‚Ä¢ Tr·∫°ng th√°i: ${stats.isRunning ? 'üü¢ ƒêang ch·∫°y' : 'üî¥ ƒê√£ d·ª´ng'}\n` +
					`‚Ä¢ T·ªïng b√†i vi·∫øt l√™n l·ªãch: ${stats.totalScheduledPosts}\n` +
					`‚Ä¢ B√†i vi·∫øt ƒëang ho·∫°t ƒë·ªông: ${stats.enabledPosts}\n` +
					`‚Ä¢ ƒê√£ ƒëƒÉng h√¥m nay: ${stats.todayPosts}\n` +
					`‚Ä¢ ƒê√£ ƒëƒÉng tu·∫ßn n√†y: ${stats.weekPosts}\n` +
					`‚Ä¢ T·ªïng l·ªãch s·ª≠: ${stats.totalPosts}`;
				return reply(statusMsg);
			}
			return reply("‚ùå Kh√¥ng th·ªÉ l·∫•y th√¥ng tin tr·∫°ng th√°i!");

		case 'list':
			const config = getAutoPostConfig();
			if (config && config.posts.length > 0) {
				let listMsg = "üìù DANH S√ÅCH B√ÄI VI·∫æT T·ª∞ ƒê·ªòNG:\n\n";
				config.posts.forEach((post, index) => {
					listMsg += `${index + 1}. ID: ${post.id}\n`;
					listMsg += `   üìÑ N·ªôi dung: ${post.content.substring(0, 50)}...\n`;
					listMsg += `   ‚è∞ Th·ªùi gian: ${post.scheduledTime}\n`;
					listMsg += `   üìÖ Ng√†y: ${post.days.join(', ')}\n`;
					listMsg += `   üìç Lo·∫°i: ${post.type}\n`;
					listMsg += `   ${post.enabled ? 'üü¢' : 'üî¥'} Tr·∫°ng th√°i: ${post.enabled ? 'Ho·∫°t ƒë·ªông' : 'T·∫°m d·ª´ng'}\n`;
					if (post.lastPosted) {
						listMsg += `   üì§ ƒêƒÉng l·∫ßn cu·ªëi: ${formatVietnamTime(post.lastPosted)}\n`;
					}
					listMsg += '\n';
				});
				return reply(listMsg);
			}
			return reply("üìù Ch∆∞a c√≥ b√†i vi·∫øt n√†o ƒë∆∞·ª£c l√™n l·ªãch!");

		case 'add':
			if (args[2] && args.slice(2).join(" ").trim()) {
				const newContent = args.slice(2).join(" ").trim();

				// Thay th·∫ø n·ªôi dung cho t·∫•t c·∫£ b√†i vi·∫øt c√≥ type "all_groups"
				const config = getAutoPostConfig();
				if (!config) {
					return reply("‚ùå Kh√¥ng th·ªÉ ƒë·ªçc c·∫•u h√¨nh autopost!");
				}

				let updatedCount = 0;
				let updatedPosts = [];

				config.posts.forEach(post => {
					if (post.type === "all_groups") {
						const oldContent = post.content;
						post.content = newContent;
						updatedCount++;
						updatedPosts.push({
							id: post.id,
							oldContent: oldContent.substring(0, 30) + "...",
							newContent: newContent.substring(0, 30) + "..."
						});
					}
				});

				if (updatedCount > 0) {
					// L∆∞u config ƒë√£ c·∫≠p nh·∫≠t
					if (saveAutoPostConfig(config)) {
						// Kh·ªüi ƒë·ªông l·∫°i scheduler ƒë·ªÉ √°p d·ª•ng thay ƒë·ªïi
						if (global.autoPostScheduler && typeof global.autoPostScheduler.restartSchedulerSilent === 'function') {
							global.autoPostScheduler.restartSchedulerSilent();
						}

						let successMsg = `‚úÖ ƒê√É THAY TH·∫æ N·ªòI DUNG TH√ÄNH C√îNG!\n\n`;
						successMsg += `üìù N·ªôi dung m·ªõi: ${newContent}\n`;
						successMsg += `üîÑ ƒê√£ c·∫≠p nh·∫≠t: ${updatedCount} b√†i vi·∫øt "all_groups"\n`;
						successMsg += `‚è∞ Th·ªùi gian: ${formatVietnamTime(Date.now())}\n\n`;
						successMsg += `üìã Danh s√°ch ƒë√£ c·∫≠p nh·∫≠t:\n`;
						updatedPosts.forEach((post, index) => {
							successMsg += `${index + 1}. ID ${post.id}: "${post.oldContent}" ‚Üí "${post.newContent}"\n`;
						});
						successMsg += `\nüîÑ Scheduler ƒë√£ ƒë∆∞·ª£c kh·ªüi ƒë·ªông l·∫°i ƒë·ªÉ √°p d·ª•ng thay ƒë·ªïi.`;

						return reply(successMsg);
					} else {
						return reply("‚ùå L·ªói l∆∞u c·∫•u h√¨nh! Vui l√≤ng th·ª≠ l·∫°i.");
					}
				} else {
					return reply("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y b√†i vi·∫øt n√†o c√≥ type 'all_groups' ƒë·ªÉ thay th·∫ø!");
				}
			} else {
				return reply("‚ö†Ô∏è Vui l√≤ng nh·∫≠p n·ªôi dung sau l·ªánh add!\nV√≠ d·ª•: /post -auto add [n·ªôi dung m·ªõi]");
			}
			break;

		case 'remove':
			return api.sendMessage(
				"üóëÔ∏è X√ìA B√ÄI VI·∫æT T·ª∞ ƒê·ªòNG:\n\n" +
				"Ph·∫£n h·ªìi tin nh·∫Øn n√†y v·ªõi ID b√†i vi·∫øt mu·ªën x√≥a.\n" +
				"D√πng l·ªánh 'post -auto list' ƒë·ªÉ xem danh s√°ch ID.",
				threadID, (e, info) => {
					global.client.handleReply.push({
						name: this.config.name,
						messageID: info.messageID,
						author: senderID,
						type: 'removeAutoPost'
					});
				}, messageID);

		case 'logs':
			try {
				const logsPath = path.join(__dirname, '..', '..', 'data', 'autopost_logs.json');
				if (fs.existsSync(logsPath)) {
					const logs = JSON.parse(fs.readFileSync(logsPath, 'utf8'));
					const recentLogs = logs.slice(-10); // 10 log g·∫ßn nh·∫•t

					let logMsg = "üìã LOG AUTO-POST (10 g·∫ßn nh·∫•t):\n\n";
					recentLogs.forEach(log => {
						logMsg += `[${log.vietnamTime}] ${log.type}: ${log.message}\n`;
					});
					return reply(logMsg);
				}
				return reply("üìã Ch∆∞a c√≥ log n√†o!");
			} catch (error) {
				return reply("‚ùå L·ªói ƒë·ªçc log: " + error.message);
			}

		case 'help':
			return reply(
				"ü§ñ H∆Ø·ªöNG D·∫™N AUTO-POST:\n\n" +
				"‚Ä¢ post -auto start - Kh·ªüi ƒë·ªông auto-post\n" +
				"‚Ä¢ post -auto stop - D·ª´ng auto-post\n" +
				"‚Ä¢ post -auto restart - Kh·ªüi ƒë·ªông l·∫°i\n" +
				"‚Ä¢ post -auto status - Xem tr·∫°ng th√°i\n" +
				"‚Ä¢ post -auto list - Danh s√°ch b√†i vi·∫øt\n" +
				"‚Ä¢ post -auto add - Th√™m b√†i vi·∫øt m·ªõi\n" +
				"‚Ä¢ post -auto add [n·ªôi dung] - Thay th·∫ø n·ªôi dung t·∫•t c·∫£ b√†i vi·∫øt all_groups\n" +
				"‚Ä¢ post -auto remove - X√≥a b√†i vi·∫øt\n" +
				"‚Ä¢ post -auto logs - Xem log ho·∫°t ƒë·ªông\n" +
				"‚Ä¢ post -auto help - H∆∞·ªõng d·∫´n n√†y"
			);

		default:
			return reply(
				"‚ùì L·ªánh kh√¥ng h·ª£p l·ªá!\n" +
				"D√πng 'post -auto help' ƒë·ªÉ xem h∆∞·ªõng d·∫´n."
			);
	}
};